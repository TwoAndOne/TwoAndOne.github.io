<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpeg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpeg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"twoandone.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="后端废物">
<meta property="og:type" content="website">
<meta property="og:title" content="Yussss">
<meta property="og:url" content="https://twoandone.github.io/page/3/">
<meta property="og:site_name" content="Yussss">
<meta property="og:description" content="后端废物">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yus">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://twoandone.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Yussss</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yussss</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">沧浪之水清兮，可以濯我缨。沧浪之水浊兮，可以濯我足</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yus"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Yus</p>
  <div class="site-description" itemprop="description">后端废物</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:2414655851@qq.com" title="E-Mail → mailto:2414655851@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://twoandone.github.io/2021/07/06/%E5%8F%A4%E5%85%B8%E9%9F%B3%E4%B9%90%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yussss">
      <meta itemprop="description" content="后端废物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Yussss">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/%E5%8F%A4%E5%85%B8%E9%9F%B3%E4%B9%90%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">古典音乐入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-06 00:25:16" itemprop="dateCreated datePublished" datetime="2021-07-06T00:25:16+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-22 17:22:45" itemprop="dateModified" datetime="2023-08-22T17:22:45+08:00">2023-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/music/" itemprop="url" rel="index"><span itemprop="name">music</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="名词解释">名词解释</h1>
<table>
<thead>
<tr class="header">
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>minuet</td>
<td>小步舞曲</td>
</tr>
<tr class="even">
<td>prelude</td>
<td>前奏</td>
</tr>
<tr class="odd">
<td>fugue</td>
<td>赋格</td>
</tr>
<tr class="even">
<td>concerto</td>
<td>协奏曲</td>
</tr>
<tr class="odd">
<td>suite</td>
<td>组曲</td>
</tr>
<tr class="even">
<td>sonata</td>
<td>奏鸣曲</td>
</tr>
<tr class="odd">
<td>waltz</td>
<td>圆舞曲</td>
</tr>
<tr class="even">
<td>symphony</td>
<td>交响曲</td>
</tr>
<tr class="odd">
<td>nocturne</td>
<td>夜曲</td>
</tr>
<tr class="even">
<td>Ballade</td>
<td>叙事曲</td>
</tr>
<tr class="odd">
<td>Aria</td>
<td>咏叹调</td>
</tr>
<tr class="even">
<td>Flute</td>
<td>长笛</td>
</tr>
<tr class="odd">
<td>March</td>
<td>进行曲</td>
</tr>
<tr class="even">
<td>Etude</td>
<td>练习曲</td>
</tr>
</tbody>
</table>
<h1 id="一些理论">一些理论</h1>
<p>音乐音响的两个基本属性：</p>
<ul>
<li>没有视觉性：不能直接传达视觉形象</li>
<li>没有语义性：不能直接传达思想概念</li>
</ul>
<p>《西西里之歌》</p>
<p>音乐是情绪的艺术</p>
<p>幸福人生最重要是什么？</p>
<p>是丰富多彩</p>
<p>为美而流泪</p>
<blockquote>
<p><strong>音乐是人类灵魂的避难所，如果你还想保持心灵的纯净，在那么喧嚣的生活当中，给自己留一点宁静，在那么龌龊的人际关系行为中，给天空留下一片崇高，你应该热爱音乐</strong></p>
</blockquote>
<blockquote>
<p><strong>最伟大的演奏家与一般的演奏家的区别在哪？</strong></p>
<p>在专注程度</p>
<p>心理习惯一旦养成，比动作系统还难改变</p>
<p>用宗教般的笃静感来对待每一个音符</p>
</blockquote>
<p>从作品的角度看：音乐能否引起明确的内容理解，取决于持续而稳定的联觉对应关系</p>
<p>从听众的角度看：敏感的联觉、丰富的联想是理解音乐的前提条件</p>
<p>音乐心理学研究告诉我们，声音只有五种属性可以引起联觉：</p>
<ol type="1">
<li>音高</li>
<li>音强</li>
<li>速度和节奏</li>
<li>发音速度</li>
<li>紧张度</li>
</ol>
<h1 id="充分触发我联觉印象的音乐们">充分触发我联觉印象的音乐们</h1>
<ol type="1">
<li><p>Prelude BWV999 鲁特琴 巴赫</p>
<iframe src="//player.bilibili.com/player.html?aid=339882748&amp;bvid=BV1dR4y1F7AD&amp;cid=554320944&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe></li>
<li><p>《沉思曲》马友友大提琴</p>
<iframe src="//player.bilibili.com/player.html?aid=375410114&amp;bvid=BV1Eo4y127CR&amp;cid=334900598&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe></li>
<li><p>《沉思曲》李映衡</p>
<iframe src="//player.bilibili.com/player.html?aid=673328197&amp;bvid=BV1rU4y1L7N9&amp;cid=343294734&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe></li>
<li><p>《月光》 德彪西</p>
<iframe src="//player.bilibili.com/player.html?aid=48446974&amp;bvid=BV1Gb41137fJ&amp;cid=84847630&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe></li>
<li><p>《流浪者之歌》</p></li>
<li><p>《》</p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://twoandone.github.io/2021/07/01/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yussss">
      <meta itemprop="description" content="后端废物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Yussss">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/01/JVM/" class="post-title-link" itemprop="url">JVM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-01 10:53:21" itemprop="dateCreated datePublished" datetime="2021-07-01T10:53:21+08:00">2021-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-22 17:22:28" itemprop="dateModified" datetime="2023-08-22T17:22:28+08:00">2023-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="jvm">JVM</h1>
<h2 id="question">Question</h2>
<ol type="1">
<li>JMM模型？</li>
<li>Java对象的定位方式？</li>
<li>说一下堆栈的区别？</li>
<li>什么情况下会发生栈溢出？</li>
<li>类文件结构</li>
<li>什么是类加载？类加载的过程？</li>
<li>什么是双亲委派模型？</li>
<li>什么是类加载器、类加载器有哪些？</li>
<li>类的实例化顺序？</li>
<li>如何判断一个对象是否存活？</li>
<li>可作为GC Roots的对象有哪些？</li>
<li>什么情况下类会被卸载？</li>
<li>强引用、软引用、弱引用、虚引用？</li>
<li>Minor GC和Full GC的区别？</li>
<li>内存的分配策略？</li>
<li>Full GC的触发条件？</li>
<li>垃圾回收算法有哪些？</li>
<li>有哪些垃圾回收器？</li>
<li>常用的JVM调优的命令有哪些？</li>
<li>如何排查OOM的问题？</li>
<li>GC是什么？为什么要GC？</li>
</ol>
<h2 id="自动内存管理">自动内存管理</h2>
<h3 id="内存区域与内存溢出异常">内存区域与内存溢出异常</h3>
<h4 id="运行时数据区域"><strong>运行时数据区域</strong></h4>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230701120937994.png"
alt="image-20230701120937994" />
<figcaption aria-hidden="true">image-20230701120937994</figcaption>
</figure>
<p><strong>PC</strong></p>
<p>线程私有，是当前线程所执行的字节码的行号指示器。为什么私有是由于多线程情况下，为了切换线程后能恢复到正确的执行位置。</p>
<p>不会出现OOM</p>
<p><strong>Java虚拟机栈</strong></p>
<p>线程私有，与线程同等生命周期。</p>
<p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，VM会创建一个栈帧用于存储局部变量表，操作数栈，动态连接，方法出口等信息。</p>
<p>每一个方法被调用直至执行完毕的过程，就是一个栈帧在虚拟机栈中从入栈到出栈道过程。</p>
<p>请求栈深度大于允许的深度，抛出栈溢出异常</p>
<p>如果栈容易可动态扩展，那么会出现OOM</p>
<p><strong>本地方法栈</strong></p>
<p>与虚拟机栈的区别是本地方法栈为本地方法服务。</p>
<p>栈深度溢出抛出StackOverflowError</p>
<p>栈扩展失败抛出OutOfMemoryError</p>
<p><strong>Java堆</strong></p>
<p>线程共享，虚拟机启动时创建，存放对象实例</p>
<p>在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出OutOfMemoryError</p>
<p><strong>方法区</strong></p>
<p>线程共享，存储类型信息、常量、静态变量、即时编译器后的代码缓存</p>
<p>方法区是一个虚拟机规范提出的概念，HotSpot是实现</p>
<p>在jdk6之前使用永久代来实现</p>
<p>jdk7至jdk8逐渐移到元空间</p>
<p>无法满足新的内存分配需求时，抛出OutOfMemoryError</p>
<p><strong>运行时常量池</strong></p>
<p>线程共享，属于方法区</p>
<p>存储常量池表：编译期间生成的各种字面量和符号引用</p>
<p>抛出OOM</p>
<p><strong>直接内存</strong></p>
<p>堆外内存，通过DirectByteBuffer对象作为这块内存的引用进行操作，避免Java堆和Native堆来回复制数据。</p>
<p>使用了内存映射，让操作系统自</p>
<p><u>除了PC其它都会抛出OOM，只有栈会抛出栈溢出</u></p>
<h4 id="hotspot虚拟机对象"><strong>HotSpot虚拟机对象</strong></h4>
<h5 id="对象的创建"><strong>对象的创建</strong></h5>
<p>new指令：</p>
<ol type="1">
<li>类加载检查：检查这个指令的参数能否在常量池中定位到一个类的符号引用，检查这个符号引用代表的类是否已被加载、解析和初始化过</li>
<li>分配内存：由Java堆是否规整决定-&gt;垃圾收集器是否带有空间压缩整理能力
<ul>
<li>指针碰撞:带压缩能力的Serial、ParNew</li>
<li>空闲列表：基于清除的CMS</li>
</ul></li>
<li>并发安全问题：
<ul>
<li>对分配空间的动作进行同步处理：CAS➕失败重试</li>
<li>TLAB：本地线程缓冲</li>
</ul></li>
<li>初始化零值</li>
<li>对象头内容初始化</li>
<li>执行构造函数</li>
</ol>
<blockquote>
<p>初始化一个对象，那肯定得给它分配内存吧，那就得知道分配多少内存吧，分配多少就得知道Class信息吧，总得找到是哪个Class吧，new关键字背后跟了参数，那就是那个类咯，所以区常量池找到它。</p>
</blockquote>
<p><strong>对象的内存布局</strong></p>
<p>对象在堆存储布局可以划分三个部分：对象头、实例数据、对齐填充</p>
<p>对象头包含两个部分：</p>
<ol type="1">
<li><p>存储对象自身的运行时数据：Mark Word</p>
<p>哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</p></li>
<li><p>类型指针：对象指向它的类型元数据的指针，Java虚拟机根据这个指针来确定该对象是哪个类的实例</p></li>
</ol>
<p>实例数据：</p>
<p>无论是父类还是子类的字段都要记录下来，相同宽度的字段被分配到一起，如shorts和chars</p>
<p>对齐填充：</p>
<p>任何对象都必须是8字节的倍数，对象头正好是。</p>
<p><strong>对象的访问定位</strong></p>
<ul>
<li>句柄</li>
<li>直接指针访问</li>
</ul>
<p>Java程序会通过栈上的reference数据来操作堆上的具体对象。</p>
<p>直接指针访问就是reference存储的就是对象地址，速度更快，HotSpot的方式</p>
<p>句柄访问就是reference存储的是句柄地址，句柄地址存储的是对象地址，多一层是为了当对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要改变。大概是reference可以有很多，让句柄池做了中介。</p>
<h4 id="outofmemoryerror异常"><strong>OutOfMemoryError异常</strong></h4>
<p><strong>堆溢出</strong></p>
<p><code>-verbose:gc -Xms20M -Xmx20M -Mmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</code></p>
<p>限制堆大小为20M，不可扩展（将堆堆最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展）</p>
<p>通过参数-
XX:+HeapDumpOnOutOfMemoryError可以让虚拟机内存溢出时候Dump出当前内存堆转储快照</p>
<p>出现异常时的处理方法：</p>
<ol type="1">
<li><p>确认内存中导致OOM的对象是否是必要的，也就是要先分清楚内存泄漏还是内存溢出</p>
<blockquote>
<p>如果是必要的，就是内存溢出，非必要的就是内存泄漏</p>
</blockquote></li>
<li><p>如果是内存泄漏，可通过工具查看泄漏对象到GC
Root的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC
Root相关联，才导致垃圾收集器无法回收。根据泄漏对象的类型信息以及它到GC
Root引用链的信息，定位具体的代码位置</p></li>
<li><p>如果是内存溢出，应当检查堆参数，-Xmx，Xms的设置，与机器的内存对比，看看是否能调整。再检查代码中是否有对象生命周期过长、持有状态时间过长、存储设计不合理的情况。</p></li>
</ol>
<p><strong>虚拟机栈和本地方法栈溢出</strong></p>
<p>-Xss 栈容量</p>
<p><strong>方法区和运行时常量池</strong></p>
<p>方法区的主要职责是用于存放类型相关信息：类名、访问修饰符、常量池、字段描述、方法描述</p>
<p>在运行时动态生成大量动态类的应用场景里，应该关注这些类的回收情况。比如大量使用CGLIb字节码增强和动态语言。</p>
<p><strong>本机直接内存溢出</strong></p>
<p>由直接内存导致的内存溢出，明显特征时Dump文件没有什么异常，文件也很小。</p>
<p>考虑是否哪里用了NIO</p>
<h3 id="垃圾收集器与内存分配策略">垃圾收集器与内存分配策略</h3>
<ol type="1">
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ol>
<p>只要在运行期间，我们才能知道程序会创建哪些对象，创建多少个对象，这部分内存的分配和回收时动态的。</p>
<h4 id="哪些内存需要回收"><strong>哪些内存需要回收？</strong></h4>
<p>只有死去的内存才需要回收，死去即不可能再被任何途径使用的对象</p>
<p><strong>如何判断对象死没死？</strong></p>
<p><strong>引用计数法</strong>：有一个地方引用，计数器就加一，引用失效就减一</p>
<p>单纯使用引用计数很难解决对象之间相互循环引用的问题</p>
<blockquote>
<p>Redis中的RedisObject也有一个计数器refcount，计数器为0则可以被回收</p>
<p>Redis使用，说明Redis一边不会出现循环引用的问题，如果出现了，也有内存过期和淘汰策略进行兜底。</p>
</blockquote>
<p><strong>可达性分析算法</strong>：通过GC
Roots根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为“引用链”，如果某个对象到GC
Roots间没有任何引用链相连，则证明此对象时不可能再被使用的。</p>
<p><u>可以把所有的对象当作图来看待，如果某个对象成了孤岛，那么就可以回收它了</u></p>
<p><u>有GC Roots的图时大陆，其它都是岛屿</u></p>
<p>GC Roots：</p>
<ol type="1">
<li>虚拟机栈中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法中JNI引用的对象</li>
<li>被同步锁持有的对象</li>
<li>虚拟机内部的引用：Class对象、异常对象、类加载器</li>
</ol>
<p><strong>强引用、软引用、弱引用、徐引用</strong></p>
<p>为了破除一个对象只有“被引用”或“未被引用”两种状态，对于描述一些“食之无味、弃之可惜”的对象时，就无能无力。</p>
<ol type="1">
<li>强引用：类似Object obj = new Object（）</li>
<li>软引用：SoftReference类，快发生异常了就丢掉它，也可以做缓存</li>
<li>弱引用：WeakReference类，遇到垃圾回收就死掉，可以用来在缓存</li>
<li>虚引用：PhantomReference类，做垃圾回收的回调</li>
</ol>
<p><strong>对象不可达了之后就会被回收吗？</strong></p>
<p>不会，宣告真正死亡，需要两次标记，一次是不可达，一次是执行finalize（）方法后也没有和大陆建立联系。</p>
<p>finalize（）方法只会被调用一次。</p>
<p>这个已经被高版本的jdk11移除</p>
<p><strong>方法区里的内存需要回收吗？</strong></p>
<p>性价比非常低的区域</p>
<p>需要回收废弃的常量和不再使用的类型</p>
<p>如何判断一个类型属于不再使用的类？</p>
<ol type="1">
<li>该类所有实例已经被回收</li>
<li>加载该类的类加载器被回收，非常难</li>
<li>该类的Class对象没有在任何地方被引用，反射也找不到</li>
</ol>
<p>达到这些也只能被允许被回收。</p>
<h4
id="什么时候回收垃圾收集算法"><strong>什么时候回收？垃圾收集算法</strong></h4>
<p><strong>分代收集理论</strong></p>
<p>将Java堆划分不同区域，根据年龄划分（熬过垃圾收集过程的次数）</p>
<p>一部分区域对象朝生夕灭，那么就只记录存活的；高频收集</p>
<p>一部分区域对象难以消灭，那么就只记录死去的；低频收集</p>
<p>正是因为分了类，才产生了“Minor GC”、“Major GC”、“Full
GC”等回收类型。</p>
<p>正是因为分了类，才能针对不同区域安排与里面存储对象存亡特征相匹配的垃圾回收算法。</p>
<p>但是两个区域之前也是会存在相互引用的关系，所以搞了一个数据结构存储这部分对象：记忆集</p>
<p><strong>标记清除算法</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230703164406419.png"
alt="image-20230703164406419" />
<figcaption aria-hidden="true">image-20230703164406419</figcaption>
</figure>
<p>三色标记法，标记出可回收的对象，然后回收。</p>
<p>缺点：</p>
<ol type="1">
<li>执行效率不稳定，随着对象数量增长而增长</li>
<li>内存空间碎片化</li>
</ol>
<p><strong>标记复制算法</strong></p>
<p><img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230703164659791.png" /></p>
<p>将内存分为两个部分，每次只使用其中一个。回收时把存活对象复制到另一部分，清理掉原来那一部分。</p>
<p>解决了标记清除算法执行效率不稳定的问题</p>
<p>缺点：</p>
<ol type="1">
<li>空间浪费了一半</li>
<li>存活对象过多时，内存复制开销大</li>
</ol>
<p><strong>标记整理算法</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230703175719627.png"
alt="image-20230703175719627" />
<figcaption aria-hidden="true">image-20230703175719627</figcaption>
</figure>
<p>与标记清除一样，选出可以回收的对象进行回收，但是回收之后会对存活的对象进行整理。</p>
<p>解决了内存碎片问题，吞吐量大</p>
<p>缺点：</p>
<ol type="1">
<li>存活对象过多时，移动对象开销大</li>
</ol>
<h4 id="可达性分析的问题"><strong>可达性分析的问题</strong></h4>
<p>HotSpot算法细节</p>
<p><strong>根节点枚举</strong></p>
<p>可回收对象的判断有两种方式一种是引用计数，一种是可达性分析；可达性分析需要从GC
Roots中开始找引用链，GC Roots集合的寻找就叫做根节点枚举</p>
<p>为了避免从方法区一个不漏的寻找，使用了OopMap数据结构来快速准确地完成GC
Roots枚举。</p>
<p><strong>安全点</strong></p>
<p>决定用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到安全点后才能够暂停。</p>
<p>安全点的设定是为了让OopMap不要太多，节约内存。</p>
<p>一般会在方法调用、循环跳转、异常跳转等程序会长时间执行的地方选取安全点。</p>
<p><strong>记忆集和卡表</strong></p>
<p>记忆集是为了解决对象跨代引用所带来的问题，避免把整个老年代加进GC
Roots扫描范围。</p>
<p>卡表是记忆集的实现，它包含很多512字节大小的卡页，如果某个卡页中出现跨代引用，那么就标记这个卡页。</p>
<p>缩减GC Roots扫描范围</p>
<p><strong>写屏障</strong></p>
<p>为了解决卡表如何维护，它们何时变脏？谁来把它们变脏？</p>
<p>何时变脏？</p>
<p>有其他分代区域中对象引用了本区域对象时，变脏的时间点原则上发生在引用类型字段赋值的那一刻。</p>
<p>如何变脏？</p>
<p>通过写屏障，可以看作是“引用类型字段赋值”这个动作的AOP切面，一般是写后屏障。</p>
<p><strong>三色标记</strong></p>
<p>我们需要在一个能保障一致性快照上才能进行对象图的遍历。</p>
<ul>
<li>白色：对象未被访问过。如果可达性分析结束，仍然是白色的对象代表不可达，需要被回收</li>
<li>黑色：已经访问过，且这个对象的所有引用都已经被扫描过，代表存活对象</li>
<li>灰色：被访问，但是这个对象至少还有一个引用没有被扫描过</li>
</ul>
<p>三色标记的过程是，先灰色再黑色的推进过程。</p>
<p>但是由于并发的情况下，用户线程有可能修改引用关系。导致应该回收的对象活下来了，应该活下来的被回收了。</p>
<p>解决方案是：</p>
<ul>
<li>增量更新</li>
<li>原始快照</li>
</ul>
<blockquote>
<p>这个三色标记没有理解透彻，下次再看吧</p>
</blockquote>
<h4 id="具体的垃圾收集器"><strong>具体的垃圾收集器</strong></h4>
<h3 id="虚拟机性能监控故障处理">虚拟机性能监控、故障处理</h3>
<h2 id="虚拟机执行子系统">虚拟机执行子系统</h2>
<h3 id="类文件结构">类文件结构</h3>
<h3 id="类加载机制">类加载机制</h3>
<p>加载、验证、准备、解析、初始化、使用、卸载</p>
<ol type="1">
<li><p>什么时候vm会去加载一个类？</p>
<p>代码中用到这个类的时候，反正最开始就是main方法所在的那个</p></li>
<li><p>什么是加载？</p>
<p>1)、通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>2)、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<p>3)、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入
口。</p>
<p>虚拟机外部的二进制流，按照虚拟机所设定的格式存储在方法区，Java堆内存会实例化一个Class对象作为程序访问方法区中的类型数据的外部接口</p></li>
<li><p>什么是验证？</p>
<p>这一步是确保你加载的信息是否符合规范，是否会危害虚拟机安全</p></li>
<li><p>什么是准备？</p>
<p>将类变量分配内存并初始化0值，这些变量和Class对象存在一起</p></li>
<li><p>什么是解析？</p>
<p>将常量池的符号引用转换为直接引用的过程。</p>
<p>符号引用类似于java中的import语句，你import进来了，我们才可以用这个类来写代码。在解析时，才真正将它与具体的对象进行联系</p></li>
<li><p>什么是初始化？</p>
<p>执行静态方法，给静态变量赋值</p>
<p>规则：当初始化一个类时，发现它的父类没有初始化那么先去初始化它的父类</p></li>
<li><p>有哪些类加载器？</p>
<p>实现上述过程都需要类加载器</p>
<ul>
<li>启动类加载器：Bootstrap ClassLoader，加载核心类lib目录</li>
<li>扩展类加载器：Extension ClassLoader，加载lib</li>
<li>应用程序加载器：Application
ClassLoader，加载ClassPath指定路径的类，就是我们写的</li>
<li>自定义类加载器</li>
</ul>
<blockquote>
<p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节
流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动
作的代码被称为“类加载器”(Class Loader)。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230704203836577.png"
alt="image-20230704203836577" />
<figcaption aria-hidden="true">image-20230704203836577</figcaption>
</figure></li>
<li><p>什么是双亲委派模型？</p>
<p>双亲委派模型的工作过程是:如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去完成加载。</p>
<p>比较两个类是否“相
等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个
Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>所以双亲委派模型一个显而易见的好处就是Java中的类随着它的类
加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类
在程序的各种类加载器环境中都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应
用程序将会变得一片混乱。</p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://twoandone.github.io/2021/06/17/Redis%E9%9D%A2%E8%AF%95%E6%94%BB%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yussss">
      <meta itemprop="description" content="后端废物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Yussss">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/17/Redis%E9%9D%A2%E8%AF%95%E6%94%BB%E7%95%A5/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-17 11:43:33" itemprop="dateCreated datePublished" datetime="2021-06-17T11:43:33+08:00">2021-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-22 17:24:37" itemprop="dateModified" datetime="2023-08-22T17:24:37+08:00">2023-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="redis">Redis</h1>
<h2 id="question">Question</h2>
<p>如果阅读完都能回答上来，那么此篇就不必看啦😊</p>
<ol type="1">
<li>了解Redis吗？说说它机制为什么快？✅</li>
<li><strong>有几种数据结构，底层分别是怎么存储的？</strong>✅</li>
<li>用过哪些数据结构？分别用在什么场景？✅</li>
<li><strong>Redis的zset是如何实现的？为什么使用跳表不使用别的数据结构？</strong>✅</li>
<li>Redis key 的过期策略？✅</li>
<li>zset如何实现排名？✅</li>
<li><strong>Redis有几种持久化方式？</strong>✅</li>
<li>Redis数据幂等性是怎么保证的？</li>
<li>Redis分布式锁你们是怎么用的，原理知道吗？</li>
<li>Redis的热Key知道吗？一个热Key导致单机访问量过高，该怎么办？</li>
<li>分布多台Redis的话，如果某一台缓存过期了，流量过大该怎么办？</li>
<li>Redis的集群方式，各有什么特点？</li>
<li>Redis Cluster的通信机制，说一下蜂巢？（没听说过）</li>
<li>Redis的aof文件过大怎么处理，怎么解决，开启aof的方式有几种？了解rewrite命令吗？✅</li>
<li>布隆过滤器怎么实现的？能否有删除功能？</li>
<li>说一下redis的主从复制过程？✅</li>
<li>Redis 的哨兵和集群？✅</li>
<li>一致性哈希算法说一下，具体扩容过程？✅</li>
<li>Redis如何实现高可用？✅</li>
</ol>
<h2 id="data-structure">Data Structure</h2>
<h3 id="simple-dynamic-string-简单动态字符串">Simple Dynamic String:
简单动态字符串</h3>
<p><strong>常数级字符串长度查询与杜绝缓冲区溢出</strong></p>
<p>Redis的实现语言是C语言，为什么Redis不直接使用C语言内置的字符串呢？</p>
<p>C语言不记录字符串长度，每次计算长度需要遍历找到\0为止，而且因为不知道为一个字符串分配了多少内存，有可能在进行拼接时产生缓冲区溢出。</p>
<p>这种简单的字符串表示，在大多数情况下都能满足要求，但是，它并不能高效地支持长度计算和追加（append）这两种操作：</p>
<ul>
<li>每次计算字符串长度（<code>strlen(s)</code>）的复杂度为 θ(N) 。</li>
<li>对字符串进行 N 次追加，必定需要对字符串进行 N
次内存重分配（<code>realloc</code>）。</li>
</ul>
<p>在 Redis 内部， 字符串的追加和长度计算很常见， 而 <a
target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/string/append.html#append">APPEND</a>
和 <a
target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/string/strlen.html#strlen">STRLEN</a>
更是这两种操作，在 Redis 命令中的直接映射，
这两个简单的操作不应该成为性能的瓶颈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">strlen</span>(str); <span class="comment">// 计算字符串长度</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>; <span class="comment">// 把src拼接到后面</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> len; <span class="comment">// 记录buf数组已使用的字节的数量</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">free</span>; <span class="comment">// 记录buf数组未使用的字节的数量</span></span><br><span class="line">  <span class="type">char</span> buf[]; <span class="comment">// 字节数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Redis3.0版本是这些字段，在最新版7.0已经变成</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了解决以上问题，SDS引入了len、free属性，len解决字符串长度问题，free+空间分配策略解决缓冲区溢出问题。</p>
<p><strong>空间分配策略：</strong></p>
<p>如果需要进行SDS修改，首先检查空间是否满足修改所需的大小，否则重新分配新的内存块。</p>
<ol type="1">
<li><p>空间预分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(len &lt; <span class="number">1</span>MB)&#123;</span><br><span class="line">	<span class="built_in">free</span> = len;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">free</span> = <span class="number">1</span>MB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发生连续执行字符串增长操作时，可以减少内存重分配次数。再次扩展SDS空间之前，如果有足够的空间，那么就不用执行内存重分配。</p>
<p>通过这种预分配策略，SDS将连续增长N次字符串所需要的内存重分配次数从必定N次降低为最多N次。</p>
<blockquote>
<p>一切都是为了更快的速度这个总目标。</p>
<p>在空间不值钱的时候，那么用空间换时间是非常划算的。进行内存重分配还需要从用户态转换为内核态，底层还需要中断操作，这些都是非常耗时的。</p>
<p>大家还能想起其它用空间换时间的🌰吗？</p>
</blockquote></li>
<li><p>惰性空间释放</p>
<p>当修改SDS字符串时，如果是截断操作，Redis会及时释放多余的空间吗？</p>
<p>为了更快的速度，既然在增加长度时都不在乎内存了，那么减少时也没有必要太节约。</p>
<p>使用<code>free</code>属性记录这些多余的空间,未来的增减更得心应手。</p></li>
</ol>
<p><strong>二进制安全</strong></p>
<p>C语言由于使用<code>'\0'</code>结束字符串，也就让C字符串无法保存图片、音频等二进制数据。</p>
<p>SDS用二进制的方式处理buf数组的数据，所以SDS二进制安全。</p>
<p><strong>兼容部分C字符串函数</strong></p>
<p>Redis是C语言写的，所以和C语言字符串的运算不可避免啊，能重用当然更好咯。</p>
<p>毕竟我们也只需要在保存的数据末尾加一个空字符就行咯。</p>
<h4 id="question-1">Question</h4>
<ol type="1">
<li>Redis的SDS设计了len属性，便于常数复杂度获取一个SDS的长度，但是Redis需要这个设计吗？什么场景下会被用到？
<ul>
<li><code>strlen()</code>命令用于获取字符串长度，难道只是为了这个吗？</li>
</ul></li>
<li>Redis有惰性释放，那么真正释放的时机是多久呢？</li>
</ol>
<h3 id="dict字典">Dict：字典</h3>
<p>字典可以结合Java中的HashMap进行学习，相似之处非常多。</p>
<p>首先我们可以看一下，它的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">  dictEntry **table; <span class="comment">// 哈希表数组</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> size; <span class="comment">// 哈希表大小</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">// size-1 ；哈希表大小掩码，用于计算哈希值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> used; <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">&#125; dictth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">  <span class="type">void</span> *key; <span class="comment">// 键</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> *val;</span><br><span class="line">    unint64_tu64;</span><br><span class="line">    int64_ts64;</span><br><span class="line">  &#125; v; <span class="comment">// 值</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 拉链法，头结法</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">  dictType *type; <span class="comment">// 类型特定函数</span></span><br><span class="line">  <span class="type">void</span> *private; <span class="comment">// 私有数据</span></span><br><span class="line">  dictht ht[<span class="number">2</span>]; <span class="comment">// 哈希表</span></span><br><span class="line">  <span class="type">int</span> rehashidx; <span class="comment">// rehash索引，也就是判断是否正在进行rehash，-1未进行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230620011207518.png"
alt="image-20230620011207518" />
<figcaption aria-hidden="true">image-20230620011207518</figcaption>
</figure>
<p>对着图来看，平平无奇就是一个普通的使用拉链法的哈希表。</p>
<p>唯一比较令人新奇的是sizemask是什么？为什么会有两个dictht，rehashidx是什么？</p>
<h4 id="哈希算法">哈希算法</h4>
<p>要了解sizemask就得了解如何计算哈希索引值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>
<p>首先使用<code>MurmurHash2</code>算法来计算键的哈希值，这个算法可以让有规律的键也给出很好的随机分布性。</p>
<p>接着由于sizemask等于size-1，那么hash值与其相与就是求哈希值对size取余。</p>
<h4 id="rehash">Rehash</h4>
<p>如果一个哈希表不堪重负，也就是说查找效率开始降低了该怎么办？又或者一个容量巨大的哈希表却只有几个元素，太浪费空间了怎么办？</p>
<p>这里的效率与浪费可以用负载因子来描述，为了让哈希表维持在进可攻退可守的状态，我们需要让负载因子(<span
class="math inline">\(Loadfacter = used
/size\)</span>)处在一个合理的水平。</p>
<p>看公式，我们能决定的只有size而已，也就是说rehash其实是在重新分配空间。</p>
<p><strong>什么情况下进行扩容：</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230620014053119.png"
alt="image-20230620014053119" />
<figcaption aria-hidden="true">image-20230620014053119</figcaption>
</figure>
<blockquote>
<p>bgsave和bgrewrite是后台持久化操作，后续会讲，总之是一个消耗CPU资源的操作。</p>
</blockquote>
<p><strong>什么情况下进行缩容：</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230620014444494.png"
alt="image-20230620014444494" />
<figcaption aria-hidden="true">image-20230620014444494</figcaption>
</figure>
<p><strong>Rehash</strong></p>
<p>无论是扩容还是缩容，都不可避免的会改变size和sizemask，而key的查询与sizemask有关，因此必须对每一个元素重新计算索引，引入新的哈希表。</p>
<ol type="1">
<li>找到新的size</li>
<li>申请内存空间，并赋给dict.ht[1].table</li>
<li>设置dict.rehashidx=0,标志正在rehash</li>
<li>将dict.ht[0]的每一个元素都rehash到dict.ht[1]</li>
<li>讲dict.ht[1]赋值给dict.ht[0]，dict.ht[1]指向空，释放原来dict.ht[0]的内存</li>
</ol>
<p>我们可以想想上述过程有什么隐患吗？</p>
<p>如果当哈希表数据有几百万上千万，第四步还能顺利完成吗？</p>
<p>由此引入了渐进式rehash</p>
<p><strong>渐进式Rehash</strong></p>
<ol type="1">
<li>找到新的size</li>
<li>申请内存空间，并赋给dict.ht[1].table</li>
<li>设置dict.rehashidx=0,标志正在rehash</li>
<li><em>每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，都检查一下dict.rehashidx是否大于-1，如果是，将ht[0].table[rehashidx]的Entry链表rehash到ht[1]，当rehash工作完成之后，并且将rehashidx属性的值增一。</em></li>
<li>将dict.ht[1]赋值给dict.ht[0]，dict.ht[1]指向空，释放原来dict.ht[0]的内存</li>
<li>将dict.rehashidx赋值为-1，代表结束rehash</li>
<li>新增操作直接写入ht[1]，查询和删除需要依次查找，这样ht[1]不停的在增加，ht[0]不停的在减少最终为空。</li>
</ol>
<h3 id="ziplist-压缩列表">ZipList: 压缩列表</h3>
<p><code>ZipList</code>是一种连续内存空间的“双端链表”，由一系列特殊编码的内存块组成，可以在任意一端进行压入与弹出，且时间复杂度为O(1)</p>
<h4 id="压缩列表的构成ziplist">压缩列表的构成:ZipList</h4>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230621011234057.png"
alt="image-20230621011234057" />
<figcaption aria-hidden="true">image-20230621011234057</figcaption>
</figure>
<p>zllen：最大值为65535，如果超过，那么就只能遍历才能知道，但是一般不会超过，因为ZipList设计初衷不是用来存很多东西的。</p>
<p>固定不变的就是总字节数、尾偏移量、entry节点数、结束标识，这些一共占11个字节。</p>
<p>尾偏移量用总字节数减去tail节点长度再减1</p>
<h4
id="压缩列表节点的构成ziplistentry">压缩列表节点的构成：ZipListEntry</h4>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230621011755420.png"
alt="image-20230621011755420" />
<figcaption aria-hidden="true">image-20230621011755420</figcaption>
</figure>
<p><code>previous_entry_length</code>：前一个节点的长度，如果前一节点的长度小于254字节，就用1个字节存储，否则用5个字节存储，其中第一个字节为0xfe用来标识。</p>
<blockquote>
<p><code>previous_entry_length</code>的设计是为了能够向前访问，由于它长度不固定，导致连锁更新的罪魁祸首就是它。连锁更新稍微想想当每个entry的长度都是253，如果某个entry增加至少一个字节之后的更新操作，就明白了。</p>
</blockquote>
<p><code>encoding</code>：编码属性占一个字节或2个字节或5个字节</p>
<p><code>content</code>：保存节点的数据，字符串或整数。可以没有（当数字小于14）</p>
<blockquote>
<p>ZipList中所有存储长度的数值均采用小端字节序，低位字节在前，高位字节在后。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230621013348769.png"
alt="image-20230621013348769" />
<figcaption aria-hidden="true">image-20230621013348769</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230621013417294.png"
alt="image-20230621013417294" />
<figcaption aria-hidden="true">image-20230621013417294</figcaption>
</figure>
<h4 id="question-2">Question</h4>
<ol type="1">
<li><p>如何实现的双向？</p>
<p>记录了上一个节点的长度与当前节点长度。</p></li>
<li><p>有什么优点和缺点？</p>
<p>优点和缺点都是由存储结构导致的，优点就是节省内存，缺点就是无法随机访问，增删可能会发生连续更新问题影响性能。</p></li>
</ol>
<h3 id="intset整数集合">IntSet:整数集合</h3>
<p>IntSet是Redis中set集合的一种实现方式，基于整数数组实现，并且具备长度、有序等特征</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> encoding; <span class="comment">// 决定保存的整数的大小 16、32、64位</span></span><br><span class="line">  <span class="type">uint32_t</span> length; <span class="comment">// 长度</span></span><br><span class="line">  <span class="type">int8_t</span> contents[]; <span class="comment">// 上面提到的数组，实际上存储的是encoding决定的类型数据</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p>为了查找方便，所有整数按照升序排列，既然有序了那么查找就可以使用二分查找。数据在集合内唯一，编码取所有整数的公倍数，俗称IntSet升级，但只会升级不会降级。</p>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230622005603455.png"
alt="image-20230622005603455" />
<figcaption aria-hidden="true">image-20230622005603455</figcaption>
</figure>
<h3 id="quicklist">QuickList</h3>
<p>链表➕数组</p>
<p>数组是ZipList，为了解决长时间使用ZipList无法获取到大块内存的弊端。还可以进一步压缩，比如除了头尾节点其他ziplist都压缩。</p>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230624214436076.png"
alt="image-20230624214436076" />
<figcaption aria-hidden="true">image-20230624214436076</figcaption>
</figure>
<h3 id="skiplist">SkipList</h3>
<p>一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。维持多个指向其它的节点的指针其实与mysql中的索引有异曲同工之妙。时间复杂度与平衡树媲美，但是实现方式更简单。</p>
<p>Redis只在两个地方用到了跳表：</p>
<ol type="1">
<li>有序集合键：集合数量较多或者成员是长字符串时</li>
<li>在集群中用作内部数据结构</li>
</ol>
<p>本质链表</p>
<ul>
<li>元素按升序排列</li>
<li>节点可能包含多个指针，指针跨度不同</li>
<li>空间换时间，加索引</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 前进节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> span; <span class="comment">// 跨度</span></span><br><span class="line">  &#125; level[]; <span class="comment">// 层</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 后退节点</span></span><br><span class="line">  <span class="type">double</span> score; <span class="comment">// 分值</span></span><br><span class="line">  robj *obj; <span class="comment">// 成员对象</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span> <span class="comment">// 头节点、尾节点</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> length; <span class="comment">// 节点数量</span></span><br><span class="line">  <span class="type">int</span> level; <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
<p>跳表由两个结构组成，zskiplist和zskiplistNode，每个跳表节点的层高都是1～32的随机数，每个成员对象必须唯一，按分值大小排序。</p>
<p>其实就是链表每次只保存下一个节点的地址，但是跳表保存了多个节点的地址，在查找的时候就可以一次性排除很多数据，，也是空间换时间的做法。</p>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230622144543868.png"
alt="image-20230622144543868" />
<figcaption aria-hidden="true">image-20230622144543868</figcaption>
</figure>
<h3 id="redisobject">RedisObject</h3>
<p>Redis中的任意数据的键和值都会封装为一个RedisObject，叫做Redis对象。</p>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230622144936198.png"
alt="image-20230622144936198" />
<figcaption aria-hidden="true">image-20230622144936198</figcaption>
</figure>
<p>ptr占用8个字节，</p>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230622145034088.png"
alt="image-20230622145034088" />
<figcaption aria-hidden="true">image-20230622145034088</figcaption>
</figure>
<p>Redis创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象，每种对象都用到了前面所介绍的数据结构。</p>
<p>对于数据库保存的键值对来说，键总是字符串对象，而值可以是任意一种。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type akey  # 查看键对象类型</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230622145110574.png"
alt="image-20230622145110574" />
<figcaption aria-hidden="true">image-20230622145110574</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object encoding akey # 查看一个数据库键对象的编码</span><br></pre></td></tr></table></figure>
<h2 id="数据类型">数据类型</h2>
<h3 id="string">String</h3>
<p>String是Redis最常见的数据存储类型：</p>
<ul>
<li><p>其最基本的编码方式是<code>RAW</code>，基于简单动态字符串实现，存储上限是512mb</p>
<blockquote>
<p>需要申请两次内存，一次是RedisObject，一次是SDS</p>
</blockquote></li>
<li><p>如果存储的SDS长度小于44字节，则会采用<code>EMBSTR</code>编码，此时object
head与SDS是一段连续空间（64字节）。申请内存时只需要调用一次内存分配函数，效率更高。</p>
<blockquote>
<p>以2的n次方进行内存分配，64字节正好是一片。</p>
<p>所以建议不要存储超过44字节的字符串，容易产生内存碎片</p>
</blockquote></li>
<li><p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用<code>INT</code>编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230624183146469.png"
alt="image-20230624183146469" />
<figcaption aria-hidden="true">image-20230624183146469</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230624183451136.png"
alt="image-20230624183451136" />
<figcaption aria-hidden="true">image-20230624183451136</figcaption>
</figure>
<p>也就是说，能用数值用数值，能小于44字节就小于。</p>
<h3 id="list">List</h3>
<p>Redis的类型可以从首位操作列表中的元素：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LPUSH l1 e3 e2 e1</span><br><span class="line">RPUSH</span><br><span class="line">LRANGE L1 0 2 // 取指定范围内的元素</span><br><span class="line">LPOP L1 1</span><br><span class="line">RPOP L1 </span><br></pre></td></tr></table></figure>
<ul>
<li>LinkedList:普通链表、双端访问，内存占用高，内存碎片多</li>
<li>ZipList：压缩列表，双端访问，内存占用低，存储上限低</li>
<li>QuickList：LinkedList+ZipList，双端访问，内存占用较低，存储上限高</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230624214436076.png"
alt="image-20230624214436076" />
<figcaption aria-hidden="true">image-20230624214436076</figcaption>
</figure>
<h3 id="set">Set</h3>
<p>Set是Redis中的集合，不一定确保元素有序，也不一定确保元素无序，满足元素唯一。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD s1 v1 v2 v3 // 添加</span><br><span class="line">SISMEMBER // 释放存在</span><br><span class="line">SINTER //交集</span><br></pre></td></tr></table></figure>
<p>可以知道，set的操作中几乎都包含对某元素的查找，所以我们需要找一个查找效率高的数据结构来实现。</p>
<p>从我们学过的：SDS、IntSet、Dict、ZipList、SkipList中找，发现Dict是效率最高的</p>
<ul>
<li>为了查询效率和唯一性，set采用Dict。key存储元素，value统一为null。</li>
<li>当存储的所有数据都是整数时，并且元素数量不超过set_max_intset_entries时，Set会采用IntSet</li>
</ul>
<p>IntSet有序使用二分查找，查询效率也还可以，存储整数时可以减少内存占用</p>
<p>Dict效率最高，但是内存占用大啊，每个Entry都有好多指针。</p>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230624221349310.png"
alt="image-20230624221349310" />
<figcaption aria-hidden="true">image-20230624221349310</figcaption>
</figure>
<p>但是IntSet不是永久的，一旦有新加入的元素不是整数或者超过了数量限制就会转换为Dict</p>
<h3 id="zset">ZSet</h3>
<p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值，它的特点是：</p>
<ul>
<li>根据score排序</li>
<li>唯一并且提交覆盖</li>
<li>可以根据member查询score</li>
</ul>
<p>因此，zst底层数据结构必须满足键值存储、键唯一、可排序</p>
<p>有序的数据结构：<code>SkipList</code>,<code>IntSet</code></p>
<p>键值关系：<code>Dict</code>，<code>SkipList</code></p>
<p>键唯一：<code>Dict</code>,</p>
<p>IntSet只能存整数，所以排除。剩下的SkipList和Dict其实都能满足，但是都需要在性能上做些让步，比如SkipList在查询键时时间负责度降为链表，Dict在排序上也捉襟见肘。</p>
<p>鉴于Redis的终极目标：FAST；不难猜到它全都要。但其实不用过于担心对内存的浪费，因为两者都只是存实际数据的指针而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZADD z1 <span class="number">10</span> m1 <span class="number">20</span> m2</span><br><span class="line">ZSCORE z1 m1</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230625150541007.png"
alt="image-20230625150541007" />
<figcaption aria-hidden="true">image-20230625150541007</figcaption>
</figure>
<p>不过由于元素数量不多时，HT和SkipList的优势并不明显，而且指针也挺费的，要8字节呢。</p>
<p>因此zst还会采用ZipList结构来节省内存，需要同时满足两个条件：</p>
<ol type="1">
<li>元素数量小于zst_max_ziplist_entries=128</li>
<li>每个元素都小于zset_max_ziplist_value=64字节</li>
</ol>
<h3 id="hash">Hash</h3>
<p>Hash结构与Reids中的Zset非常类似</p>
<ul>
<li>都是键值存储</li>
<li>都需要根据键获取值</li>
<li>键必须唯一</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hset user name yus age <span class="number">21</span></span><br><span class="line">hget user name</span><br></pre></td></tr></table></figure>
<p>区别如下：</p>
<ul>
<li>zset的键是member，值时score；hash的键和值都是任意值</li>
<li>zset要根据score排序；hash则无需排序</li>
</ul>
<p>因此，Hash底层采用的编码与Zset也基本一致，只需要把排序相关的SkipList去掉即可</p>
<ul>
<li><p>Hash结构默认采用ZipList编码，用以节约内存。ZipList中相邻的两个entry分别保存field和value</p></li>
<li><p>当数据量较大时，hash结构会转换为HT编码</p>
<ul>
<li>ZipList中的数量超过了hash_max_ziplist_entry=512</li>
<li>ZipList中的任意entry大小超过了hash_max_ziplist_value=64字节</li>
</ul>
<blockquote>
<p>为什么这里比Zset的数量少？</p>
<p>因为hash只需要存就行了，不需要排序等操作，所以存多点也没关系</p>
</blockquote></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230625161200201.png"
alt="image-20230625161200201" />
<figcaption aria-hidden="true">image-20230625161200201</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/TwoAndOne/my-images/master/uPic/image-20230625161408072.png"
alt="image-20230625161408072" />
<figcaption aria-hidden="true">image-20230625161408072</figcaption>
</figure>
<h2 id="内存策略">内存策略</h2>
<p>Redis之所以性能强，最主要的原因是基于内存存储，然而单节点的Redis其内存大小不宜过大，会影响持久化，或主从同步性能。</p>
<p>可以通过配置文件来设置Redis的最大内存：</p>
<p><code>maxmemory 1gb</code></p>
<p>当内存使用达到上限时，就无法存储更多的数据了。</p>
<p>所以我们Redis就提供了两种不同的策略</p>
<ul>
<li>过期策略</li>
<li>淘汰策略</li>
</ul>
<h3 id="过期策略">过期策略</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name jack</span><br><span class="line">expire name 5 <span class="comment"># 设置ttl为5s</span></span><br></pre></td></tr></table></figure>
<p>这里有两个问题需要我们思考：</p>
<ol type="1">
<li>Redis是如何知道一个key是否过期？</li>
<li>是不是TTL到期就立即删除了呢？</li>
</ol>
<h4 id="db结构">DB结构</h4>
<p>Redis本身是一个典型的k-v结构，因此所有的key、value都保存在之前学习的Dict中。不过在database结构体中，有两个Dict：一个用来记录k-v，一个用来记录k-ttl</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">  dict *dict;</span><br><span class="line">  dict *expires;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="../../../../../Library/Application%20Support/typora-user-images/image-20230625201220167.png"
alt="image-20230625201220167" />
<figcaption aria-hidden="true">image-20230625201220167</figcaption>
</figure>
<h4 id="惰性删除">惰性删除</h4>
<p>每次访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p>
<h4 id="周期删除">周期删除</h4>
<p>通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。执行周期有两种：</p>
<ul>
<li>SLOW模式执行频率默认为10，每次不超过25ms</li>
<li>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li>
</ul>
<blockquote>
<p>删除的算法与渐进式hash有异曲同工之妙，也会记录上一次删到哪了，然后慢慢删</p>
</blockquote>
<ol type="1">
<li><p>Redis是如何知道一个key是否过期？</p>
<p>通过记录的ttl知道</p></li>
<li><p>是不是TTL到期就立即删除了呢？</p>
<p>惰性删除➕周期删除</p></li>
</ol>
<h3 id="淘汰策略">淘汰策略</h3>
<p>内存淘汰：当Redis内存使用设置的阈值时，Redis主动挑选部分key删除以释放更多内存的流程。</p>
<p>LRU（Least Recently
Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p>
<p>LFU（Least Frequently
Used），最少频率使用。会统计每个Key的访问频率，值越少淘汰优先级越高。</p>
<p>都是保存在RedisObject对象的lru属性中。</p>
<p>Redis是有内存上限的，为了避免到达内存上限，它有两种不同的策略，一个是内存过期，一个是内存淘汰。内存过期呢其实是设置一个key的过期时间，到期以后我们就可以想办法把它删掉，删的策略呢有两种，一种是惰性删除，就是指当你访问的那一刻我检查一下有没有过期，过期了就删除；另外一个呢是周期删除，Redis有周期性任务，每隔一段时间就尝试去清理一部分过期的key。这就是所谓的过期策略，这样的策略只能把那些过期的key删掉，如果说我们这些key都没过期，而Redis内存又已经跑到上限了，又该怎么办呢？这时候就应该采用内存淘汰策略。内存淘汰策略有8种，一种是不做驱逐，内存不足就报错；还有七种呢？包括两个随机的，两个LRU，两个LFU和一个TTL，所谓的两个是指，它可以从所有key淘汰，也可以从过期key里淘汰</p>
<p><strong>单节点Redis的问题</strong></p>
<ol type="1">
<li><p>数据丢失问题：实现Redis数据持久化</p>
<p>Redis是内存存储，服务重启可能会丢失数据</p></li>
<li><p>并发能力问题：搭建主从集群，实现读写分离</p>
<p>单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景</p></li>
<li><p>故障恢复问题：利用Redis哨兵，实现健康检测和自动恢复</p>
<p>如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段</p></li>
<li><p>存储能力问题：搭建分片集群，利用插槽机制实现动态扩容</p>
<p>Redis基于内存，单节点能存储的数据难以满足海量数据的要求</p></li>
</ol>
<h2 id="持久化">持久化</h2>
<h3 id="rdb持久化">RDB持久化</h3>
<p>RDB全称Redis Database Backup
file，也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录在磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p>
<p>快照文件称为RDB文件，默认是保存在当前运行目录。</p>
<ul>
<li>save ：由Redis主进程执行RDB，会阻塞所有命令</li>
<li>bgsave：开启子进程执行RDB，避免主进程受到影响</li>
</ul>
<p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件。</p>
<p>fork采用的是copy-on-write技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作</li>
</ul>
<figure>
<img
src="../../../../../Library/Application%20Support/typora-user-images/image-20230628145725421.png"
alt="image-20230628145725421" />
<figcaption aria-hidden="true">image-20230628145725421</figcaption>
</figure>
<p>所有进程都无法操作物理内存，而是由操作系统给每个进程分配一个虚拟内存。操作系统会维护一个虚拟内存与物理内存的地址映射表，这个表称之为页表。</p>
<p>fork会拷贝映射关系页表，将共享内存设置为只读，如果主进程要修改，就得拷贝一份新的去修改。</p>
<ol type="1">
<li><p>RDB会在什么时候执行？</p>
<p>默认是服务停止时。</p></li>
<li><p>save 60 1000 代表什么含义？</p>
<p>代表60s内至少执行1000次修改则触发RDB</p></li>
<li><p>RDB的缺点？</p>
<p>RDB执行间隔长，两次RDB之间写入数据有丢失的风险</p>
<p>fork子进程，压缩，写出RDB文件都比较耗时</p></li>
</ol>
<h3 id="aof持久化">AOF持久化</h3>
<p>AOF全称为Append Only
File（追加文件）。Redis处理的每一个命令都会记录在AOF文件，可以看做是命令日志文件。</p>
<p>因为是记录命令，AOF文件比RDB文件大得多。而且AOF会记录同一个key的多次写操作，但只有最后一次写操作才有意义。通过<code>bgrewrited</code>命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 42%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>持久化方式</td>
<td>定时对整个内存做快照</td>
<td>记录每一次执行命令</td>
</tr>
<tr class="even">
<td>数据完整性</td>
<td>不完整，两次备份之间会丢失</td>
<td>相对完整，取决于刷盘策略</td>
</tr>
<tr class="odd">
<td>宕机恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr class="even">
<td>数据恢复优先级</td>
<td>低，因为完整性不如AOF</td>
<td>高</td>
</tr>
<tr class="odd">
<td>系统资源占用</td>
<td>高，大量CPU和内存消耗</td>
<td>低，主要是磁盘IO，但AOF重写会占用大量CPU和内存</td>
</tr>
<tr class="even">
<td>使用场景</td>
<td>可用容忍分钟级的数据丢失，追求更高的启动速度</td>
<td>对数据安全性要求较高</td>
</tr>
<tr class="odd">
<td>文件大小</td>
<td>会有压缩，体积小</td>
<td>记录命令，体积大</td>
</tr>
</tbody>
</table>
<h2 id="主从">主从</h2>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>
<h3 id="全量同步">全量同步</h3>
<figure>
<img
src="../../../../../Library/Application%20Support/typora-user-images/image-20230629201452329.png"
alt="image-20230629201452329" />
<figcaption aria-hidden="true">image-20230629201452329</figcaption>
</figure>
<p><u>master
如何判断slave是不是第一次来同步数据？</u>这里会用到两个很重要的概念：</p>
<ul>
<li>Replication
Id：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li>
<li>offset：偏移量，随着记录在repl_baklog的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li>
</ul>
<p>因此slave做数据同步，必须向master声明字节的replication
id和offset，master才可以判断到底需要同步哪些数据</p>
<p><strong>master如何判断slave节点是不是第一次来做数据同步？</strong></p>
<p>首先slave带着replication
id来同步，如果id与自己的相同，说明就是之前来过了，然后就可以根据offset来判断同步哪些数据。</p>
<p>主从第一次同步是全量同步</p>
<ol type="1">
<li>slave节点请求增量同步</li>
<li>master节点判断replid，发现不一致，拒绝增量同步</li>
<li>master将完整的内存数据生成RDB，发送到slave</li>
<li>slave清空本地数据，加载master到RDB</li>
<li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li>
</ol>
<h3 id="增量同步">增量同步</h3>
<figure>
<img
src="../../../../../Library/Application%20Support/typora-user-images/image-20230629202453611.png"
alt="image-20230629202453611" />
<figcaption aria-hidden="true">image-20230629202453611</figcaption>
</figure>
<p>repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致未备份的数据被覆盖，则无法基于log做增量同步，只能再次全量同步。</p>
<h3 id="哨兵">哨兵</h3>
<p><strong>slave节点宕机恢复后可以找master节点同步数据，那master节点宕机怎么办？</strong></p>
<h4 id="哨兵的作用">哨兵的作用</h4>
<p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p>
<ul>
<li>监控：Sentinel会不断检查您的master和slave是否按预期工作</li>
<li>自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。</li>
<li>通知：Sentinel充当reids客户端的服务发现来源，当集群发生故障转移时，会将最新消息推送给Redis的客户端。</li>
</ul>
<figure>
<img
src="../../../../../Library/Application%20Support/typora-user-images/image-20230629203541757.png"
alt="image-20230629203541757" />
<figcaption aria-hidden="true">image-20230629203541757</figcaption>
</figure>
<h4 id="服务状态监控">服务状态监控</h4>
<p>Sentinel基于心跳机制监测服务状态，每隔1s向集群的每个实例发送ping命令：</p>
<ul>
<li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线</li>
<li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过半数</li>
</ul>
<figure>
<img
src="../../../../../Library/Application%20Support/typora-user-images/image-20230629203837398.png"
alt="image-20230629203837398" />
<figcaption aria-hidden="true">image-20230629203837398</figcaption>
</figure>
<h4 id="选举新的master">选举新的master</h4>
<p>一旦发现master故障，sentinel需要在slave中选择一个作为新的master，选择依据如下：</p>
<ol type="1">
<li>首先判断slave节点<strong>与master节点断开的时间</strong>长短，如果超过指定值（down-after-milliseconds*10)则会排除该slave节点</li>
<li>然后判断slave节点的<strong>slave-priority值</strong>，越小优先级越高，如果是0则永不参与选举</li>
<li>如果slave-prority一样，则判断slave节点的<strong>offset值</strong>，越大说明数据越新，优先级越高</li>
<li>最后是判断slave节点的运行id大小，越小优先级越高</li>
</ol>
<h4 id="如何实现故障转移">如何实现故障转移</h4>
<p>当选中了其中一个slave为新的master后，故障的转移的步骤如下：</p>
<ul>
<li>首先选定一个slave作为新的master，执行slaveof no one</li>
<li>然后让所有节点都执行slaveof 新的master</li>
<li>修改故障节点配置，添加slaveof 新master</li>
</ul>
<h3 id="分片集群">分片集群</h3>
<p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li>海量数据存储问题</li>
<li>高并发写的问题</li>
</ul>
<p>使用分片集群可以解决上述问题，分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同数据</li>
<li>每个master都可以有多个slave节点</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可以访问集群任意节点，最终都会到达正确的节点</li>
</ul>
<h2 id="网络模型">网络模型</h2>
<h3 id="用户空间和内核空间">用户空间和内核空间</h3>
<p>为了避免用户应用导致冲突甚至内核崩溃，用户空间与内核是分离的：</p>
<ul>
<li><p>进程的寻址空间会划分两部分：内核空间、用户空间</p>
<p>这个地址是一个无符号整数，最大值取决于</p></li>
</ul>
<h3 id="io模型">IO模型</h3>
<ul>
<li>Blocking IO</li>
<li>Nonblocking IO</li>
<li>IO Multiplexing</li>
<li>Signal Driven IO</li>
<li>Asynchronous IO</li>
</ul>
<h4 id="blocking-io">Blocking IO</h4>
<figure>
<img
src="../../../../../Library/Application%20Support/typora-user-images/image-20230629183958383.png"
alt="image-20230629183958383" />
<figcaption aria-hidden="true">image-20230629183958383</figcaption>
</figure>
<p>两个阶段用户进程都在阻塞。</p>
<h4 id="nonblocking-io">Nonblocking IO</h4>
<figure>
<img
src="../../../../../Library/Application%20Support/typora-user-images/image-20230629184153087.png"
alt="image-20230629184153087" />
<figcaption aria-hidden="true">image-20230629184153087</figcaption>
</figure>
<p>非阻塞IO模型，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</p>
<h4 id="io-mutiplexing">IO Mutiplexing</h4>
<p>无论是阻塞IO合适非阻塞IO，用户应用在第一个阶段都需要调用recvfrom来获取数据，差别在无数据时的处理方案：</p>
<ul>
<li>如果调用recvfrom时，恰好没有数据，阻塞IO会使进程阻塞，非阻塞IO会使CPU空转，都不能充分发挥CPU的作用。</li>
<li>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据。</li>
</ul>
<p>比如服务端处理客户端Socket请求时，在单线程情况下，只能依次处理每一个socket，如果正在处理的socket恰好未就绪，线程就会阻塞，所有其他客户端socket都必须等待，性能自然会很差。</p>
<p>要提高有几种方法？</p>
<ol type="1">
<li>每个socket准备一个线程：多线程</li>
<li>哪个socket准备好了，就先去处理它</li>
</ol>
<h3 id="redis网络模型">Redis网络模型</h3>
<p>Redis到底是单线程还是多线程？</p>
<ul>
<li>如果仅仅是聊Reids的核心业务（命令处理），答案是单线程</li>
<li>如果是聊整个Redis，那么答案是多线程</li>
</ul>
<p>在Redis版本迭代过程中，在两个重要的时间节点引入了多线程的支持：</p>
<ul>
<li>4.0；引入了多线程异步处理一些耗时较长的任务，例如异步删除命令unlink</li>
<li>6.0；在核心网络模块引入了多线程，进一步提高了对于多核CPU的利用率</li>
</ul>
<p><strong>为什么Reids要选择单线程？</strong></p>
<ol type="1">
<li>抛开持久化不谈，Reids是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li>
<li>多线程会导致过多的上下文切换，带来不必要的开销</li>
<li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://twoandone.github.io/2021/05/26/%E7%90%86%E8%A7%A3ifconfig%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yussss">
      <meta itemprop="description" content="后端废物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Yussss">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/26/%E7%90%86%E8%A7%A3ifconfig%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">ifconfig命令初探</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-26 17:00:29" itemprop="dateCreated datePublished" datetime="2021-05-26T17:00:29+08:00">2021-05-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-08-09 17:09:48" itemprop="dateModified" datetime="2022-08-09T17:09:48+08:00">2022-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://github.com/twoandone/my-images/raw/master/img/image-20210526170305005.png" alt="image-20210526170305005" style="zoom:80%;" /></p>
<p>ifconfig是Linux里查看和配置网卡的命令。</p>
<p>如上图所示</p>
<p>br-c5a9cfdba998、docker0、ens33等都是网卡的名字，其实还有lo，virbr0等网卡，由于版面就没截图了，lo全称loopback，表示回环地址，用于本机通信，经过内核处理直接返回s，ens代表由主板bios内置的PCI-E网卡（Peripheral
Component Interconnect
Express，根据接口类型，无线网卡分为USB网卡和PCI-E网卡）</p>
<p><code>flags=4099&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;</code>是网卡状态</p>
<p><code>mtu</code>全称<code>Maximum transmission unit</code>，最大传输单元，以字节为单位，是数据链路层的概念</p>
<p><code>inet</code>表示网卡的ip地址</p>
<p><code>netmask</code>表示子网掩码</p>
<p><code>ether</code>表示网卡的MAC地址</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 43%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">OSI中的层</th>
<th style="text-align: left;">功能</th>
<th style="text-align: left;">TCP/IP协议族</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">应用层</td>
<td
style="text-align: left;">文件传输，电子邮件，文件服务，虚拟终端</td>
<td
style="text-align: left;">TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</td>
</tr>
<tr class="even">
<td style="text-align: left;">表示层</td>
<td style="text-align: left;">数据格式化，代码转换，数据加密</td>
<td style="text-align: left;">没有协议</td>
</tr>
<tr class="odd">
<td style="text-align: left;">会话层</td>
<td style="text-align: left;">解除或建立与别的接点的联系</td>
<td style="text-align: left;">没有协议</td>
</tr>
<tr class="even">
<td style="text-align: left;">传输层</td>
<td style="text-align: left;">提供端对端的接口</td>
<td style="text-align: left;">TCP，UDP</td>
</tr>
<tr class="odd">
<td style="text-align: left;">网络层</td>
<td style="text-align: left;">为数据包选择路由</td>
<td style="text-align: left;">IP，ICMP，RIP，OSPF，BGP，IGMP</td>
</tr>
<tr class="even">
<td style="text-align: left;">数据链路层</td>
<td style="text-align: left;">传输有地址的帧以及错误检测功能</td>
<td style="text-align: left;">SLIP，CSLIP，PPP，ARP，RARP，MTU</td>
</tr>
<tr class="odd">
<td style="text-align: left;">物理层</td>
<td style="text-align: left;">以二进制数据形式在物理媒体上传输数据</td>
<td style="text-align: left;">ISO2110，IEEE802，IEEE802.2</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://twoandone.github.io/2021/04/23/%E5%AD%90%E9%9B%86%E2%85%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yussss">
      <meta itemprop="description" content="后端废物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Yussss">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/23/%E5%AD%90%E9%9B%86%E2%85%A1/" class="post-title-link" itemprop="url">子集Ⅱ</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-23 16:33:13" itemprop="dateCreated datePublished" datetime="2021-04-23T16:33:13+08:00">2021-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-18 01:02:17" itemprop="dateModified" datetime="2022-07-18T01:02:17+08:00">2022-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="子集-ii"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h4>
<p>给你一个整数数组 <code>nums</code>
，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按
<strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<p>回溯算法的启蒙，做这道题思考了很久，也算是在生活中用到了回溯吧，我决定先不做这道题，先去做<a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46.
全排列</a>，做完全排列之后，这道题就有了思路。</p>
<p>全排列的实质是遍历多叉树,假如数组是[1,2,3]</p>
<p><img src="https://github.com/TwoAndOne/my-images/raw/master/img/image-20210423164923562.png" alt="image-20210423164923562" style="zoom:50%;" /></p>
<p>所以我们的思路就是</p>
<ul>
<li>终止条件
<ul>
<li>遍历到最后一个，也就是数组长度等于3的时候</li>
</ul></li>
<li>使用循环语句把每一个分支遍历到</li>
<li>在循环语句内部使用递归调用本函数接着遍历子树</li>
<li>同一层的结点遍历结束后需要回溯，举个例子，当遍历到[1,1,1]时下一个应该遍历[1,1,2]，此时在添加了[1,1,1]之后需要把最后一个1删除以增加空位。</li>
</ul>
<p>当然这只是第一步，得到全排列还需要剪枝，因为[1,1,1]这种排列并不是我们需要的，不过我们可以先实现这一种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; list, ArrayList&lt;Integer&gt; tmp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size()==nums.length)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            tmp.add(nums[i]);</span><br><span class="line">            bfs(nums,list,tmp);</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>问题来了，我们怎么剪枝呢？</p>
<p>简单的方法就是，我们在tmp.add(nums[i])之前进行判断tmp中是否已经有这个数了，如果有了就continue。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(tmp.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.add(nums[i]);</span><br><span class="line">            bfs(nums,list,tmp);</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法是用一个标记数组进行记录被使用过的数字，这种也是回溯算法常用的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length]; <span class="comment">//初始时都为false</span></span><br><span class="line">       bfs(nums,list,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),used);</span><br><span class="line">       <span class="keyword">return</span>  list;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; list, ArrayList&lt;Integer&gt; tmp,<span class="type">boolean</span>[] used)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(tmp.size()==nums.length)&#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">           tmp.add(nums[i]);</span><br><span class="line">           used[i] = <span class="literal">true</span>;</span><br><span class="line">           bfs(nums,list,tmp,used);</span><br><span class="line">           tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">           used[i] = <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>好的，全排列是大功告成啦！</p>
<p>但是子集还没搞定</p>
<p>先从<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78.
子集</a>开始</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">子集的示例：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,3],[2],[2,3],[3]]</span><br><span class="line">全排列的示例：</span><br><span class="line">[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>
<p>从示例中可以看出，子集会把tmp数组每一次变化加入list中，而全排列则需要在tmp数组长度为3时才加入</p>
<p>总结一下：</p>
<ul>
<li>终止条件
<ul>
<li>tmp数组长度等于nums.length</li>
</ul></li>
<li>tmp数组的每一次变化都需要加入进返回数组list</li>
<li>循环语句中，子集的剪枝可以从示例中看出，子集不需要回头</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; list, ArrayList&lt;Integer&gt; tmp,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size()==nums.length) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        tmp.add(nums[i]);</span><br><span class="line">        dfs(nums,list,tmp,i+<span class="number">1</span>);</span><br><span class="line">        tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子集Ⅱ与子集的区别就是给定的数组里有重复的数字</p>
<p>加入给定数组[1,2,2]，不能出现，[1,2],[1,2]的情况，也就是挑选了下标为0，1和下标为0，2的的情况是一样的，不能出现这种情况</p>
<p>容易想到的方法是，先对数组进行排序，如果nums[i]与nums[i-1]相等就跳过下标为i的情况</p>
<p>考虑到边界条件，i必须大于0，但是只考虑这两种[1,2,2]的情况就会被排除，所以必须让for循环至少执行一次，也就是i大于index并且nums[i]与nums[i-1]相等时才不考虑i这种情况，当i等于index会保证至少执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    dfs(nums,list,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; list, ArrayList&lt;Integer&gt; tmp,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size()==nums.length) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;index&amp;&amp;nums[i-<span class="number">1</span>]==nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tmp.add(nums[i]);</span><br><span class="line">        dfs(nums,list,tmp,i+<span class="number">1</span>);</span><br><span class="line">        tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://twoandone.github.io/2021/04/11/LockSupport%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yussss">
      <meta itemprop="description" content="后端废物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Yussss">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/11/LockSupport%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">LockSupport的使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-11 18:37:50" itemprop="dateCreated datePublished" datetime="2021-04-11T18:37:50+08:00">2021-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-18 01:02:25" itemprop="dateModified" datetime="2022-07-18T01:02:25+08:00">2022-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;child thread begin park!&quot;</span>);</span><br><span class="line">                LockSupport.park();<span class="comment">//P操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;child thread unpark!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread begin unpark!&quot;</span>);</span><br><span class="line">        LockSupport.unpark(thread);<span class="comment">//V操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure>
<img
src="https://github.com/TwoAndOne/my-images/raw/master/img/image-20210411184508095.png"
alt="image-20210411184508095" />
<figcaption aria-hidden="true">image-20210411184508095</figcaption>
</figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://twoandone.github.io/2021/04/11/%E5%85%B7%E6%9C%89%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E9%A1%BA%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yussss">
      <meta itemprop="description" content="后端废物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Yussss">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/11/%E5%85%B7%E6%9C%89%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E9%A1%BA%E5%BA%8F/" class="post-title-link" itemprop="url">具有继承关系的对象创建顺序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-11 13:08:04" itemprop="dateCreated datePublished" datetime="2021-04-11T13:08:04+08:00">2021-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-18 01:02:34" itemprop="dateModified" datetime="2022-07-18T01:02:34+08:00">2022-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Talk is cheap, show me the code.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a++;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态块a:&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    A()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A构造a:&quot;</span>+a);</span><br><span class="line">        System.out.println(<span class="string">&quot;A的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        b++;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态块b:&quot;</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">    B()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B构造b:&quot;</span>+b);</span><br><span class="line">        System.out.println(<span class="string">&quot;B的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure>
<img
src="https://gitee.com/yuswork/my-images/raw/master/img/image-20210411131114234.png"
alt="image-20210411131114234" />
<figcaption aria-hidden="true">image-20210411131114234</figcaption>
</figure>
<p><strong>分析</strong></p>
<p><code>new</code>关键字用于实例化一个对象，而实例化一个对象首先要确保一个类已经被加载进JVM中</p>
<p>类加载的过程分为</p>
<ol type="1">
<li><p>加载：生产Class对象，存在方法区</p></li>
<li><p>连接</p>
<ol type="1">
<li>验证：文件格式、元数据、字节码、符号引用验证</li>
<li>准备：为类变量分配内存，也就是被<code>static</code>关键字修饰的变量</li>
<li>解析：将常量池的符号引用替换成直接引用，也就是得到类或字段、方法在内存中的指针或者偏移量</li>
</ol></li>
<li><p>初始化：如果父类未初始化，会先触发父类的初始化，初始化会按照代码顺序依次执行静态变量和静态块，如下图，在静态块中引用未初始化的静态变量会编译失败。</p>
<figure>
<img
src="https://github.com/TwoAndOne/my-images/raw/master/img/image-20210411141955637.png"
alt="image-20210411141955637" />
<figcaption aria-hidden="true">image-20210411141955637</figcaption>
</figure></li>
</ol>
<p><strong>总结</strong></p>
<p>所以运行结果是输出A类的静态块接着输出B类的静态块，然后因为类已经加载进来了，所以第二次new的时候就不需要执行被static修饰的部分了</p>
<p>实例化对象时，通过构造方法实现，如果有父类需要先实例化父类再实例化子类。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://twoandone.github.io/2021/03/23/RocketMQ%202m2s%20%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%20Mac+Windows/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yussss">
      <meta itemprop="description" content="后端废物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Yussss">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/23/RocketMQ%202m2s%20%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%20Mac+Windows/" class="post-title-link" itemprop="url">RocketMQ 2m2s 集群搭建踩坑记录 Mac+Windows</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-23 13:42:25" itemprop="dateCreated datePublished" datetime="2021-03-23T13:42:25+08:00">2021-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-18 01:28:37" itemprop="dateModified" datetime="2022-07-18T01:28:37+08:00">2022-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>离离原上谱，究极操作，在 Mac OS 系统和 Windows 系统上搭建 rocketmq
双主双从集群，踩坑指南，搭建完成，凭记忆写写遇到的坑。</p>
<ol type="1">
<li>首先安装官网教程搭建一遍单节点的教程，如果有问题再看以下文档
https://rocketmq.apache.org/docs/quick-start/</li>
<li>双主双从，因为笔者只有两台电脑，分别查询 ip 地址，并配置 host</li>
</ol>
<table>
<thead>
<tr class="header">
<th>mac</th>
<th>windows</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>192.168.31.116</td>
<td>192.168.31.22</td>
</tr>
</tbody>
</table>
<p>先互相 ping 一下，看看能不能 ping 通</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nameserver</span></span><br><span class="line">192.168.31.116 rocketmq-nameserver1</span><br><span class="line">192.168.31.22 rocketmq-nameserver2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">broker</span></span><br><span class="line">192.168.31.116 rocketmq-master1</span><br><span class="line">192.168.31.116 rocketmq-slave2</span><br><span class="line"></span><br><span class="line">192.168.31.22 rocketmq-master2</span><br><span class="line">192.168.31.22 rocketmq-slave1</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>创建消息存储路径 选择一个路径创建两个文件夹</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/yus/workspace/i</span><br><span class="line">mkdir rocketmq/store-a</span><br><span class="line">mkdir rocketmq/store-b</span><br><span class="line">sudo chmod -R 777 rocketmq # 授权</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://github.com/TwoAndOne/my-images/raw/master/uPic/image-20220320212940772.png"
alt="image-20220320212940772" />
<figcaption aria-hidden="true">image-20220320212940772</figcaption>
</figure>
<p>这里就是一个坑，当时我按步骤操作完之后，启动 broker ,查看日志
<code>tail -200f ~/logs/rocketmqlogs/broker.log</code> 一直报错</p>
<figure>
<img
src="https://github.com/TwoAndOne/my-images/raw/master/uPic/image-20220320213846290.png"
alt="image-20220320213846290" />
<figcaption aria-hidden="true">image-20220320213846290</figcaption>
</figure>
<p>所以你看我的图片上的文件名被黄色背景包裹起来了，其实就是权限的问题，默认不给编辑权限。为了找到这个错，还专门用
idea 启动 broker，进行 debug。下图是 idea 启动 broker 需要的配置：</p>
<figure>
<img
src="https://github.com/TwoAndOne/my-images/raw/master/uPic/image-20220320214201826.png"
alt="image-20220320214201826" />
<figcaption aria-hidden="true">image-20220320214201826</figcaption>
</figure>
<ol type="1">
<li>broker 配置文件 我们需要在 Mac 上配置 master1 和 slave2</li>
</ol>
<p>进入到路径：<code>/Users/yus/workspace/i/rocketmq-rocketmq-all-4.6.0/distribution/target/rocketmq-4.6.0/rocketmq-4.6.0/conf/2m-2s-sync/broker-a.properties</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所属集群名字</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">暴露的外网IP</span></span><br><span class="line">brokerIP1=192.168.31.116</span><br><span class="line">brokerIP2=192.168.31.22</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker-a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">存储路径</span></span><br><span class="line">storePathRootDir=/Users/yus/workspace/i/rocketmq/store-a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/Users/yus/workspace/i/rocketmq/store-a/commitlog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/Users/yus/workspace/i/rocketmq/store-a/consumequeue</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">消息索引存储路径</span></span><br><span class="line">storePathIndex=/Users/yus/workspace/i/rocketmq/store-a/index</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/Users/yus/workspace/i/rocketmq/store-a/checkpoint</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">abort 文件存储路径</span></span><br><span class="line">abortFile=/Users/yus/workspace/i/rocketmq/store-a/abort</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Broker 的角色</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">- SLAVE</span></span><br><span class="line">brokerRole=SYNC_MASTER</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">刷盘方式</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=SYNC_FLUSH</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">checkTransactionMessageEnable=<span class="literal">false</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">发消息线程池数量</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉消息线程池数量</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>
<p>进入到路径：<code>/Users/yus/workspace/i/rocketmq-rocketmq-all-4.6.0/distribution/target/rocketmq-4.6.0/rocketmq-4.6.0/conf/2m-2s-sync/broker-b-s.properties</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker-b</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=11011</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">存储路径</span></span><br><span class="line">storePathRootDir=/Users/yus/workspace/i/rocketmq/store-b</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/Users/yus/workspace/i/rocketmq/store-b/commitlog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/Users/yus/workspace/i/rocketmq/store-b/consumequeue</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">消息索引存储路径</span></span><br><span class="line">storePathIndex=/Users/yus/workspace/i/rocketmq/store-b/index</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/Users/yus/workspace/i/rocketmq/store-b/checkpoint</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">abort 文件存储路径</span></span><br><span class="line">abortFile=/Users/yus/workspace/i/rocketmq/store-b/abort</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Broker 的角色</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">- SLAVE</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">刷盘方式</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">- ASYNC_FLUSH 异步刷</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">checkTransactionMessageEnable=<span class="literal">false</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">发消息线程池数量</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉消息线程池数量</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>
<p>windows
里，也同样需要配置这个，不过是broker-b.properties，broker-a-s.properties。</p>
<p>需要更改的是以下几个路径，要换成 windows 里你创建的 store-a 和
store-b 的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#存储路径</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">#消息索引存储路径</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">#abort 文件存储路径</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>其实这里有个坑的，不要自己去创建
commitLog、consumequeue、index、checkpoint
的文件夹，不然会报错。B站的黑马教程误我！<img
src="https://github.com/TwoAndOne/my-images/raw/master/uPic/image-20220320215716362.png"
alt="image-20220320215716362" /></li>
<li>修改启动 broker 的文件，里面的内存加太大了,windows 里改.cmd 结尾的
<code>xxx/bin/runbroker.sh</code></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m&quot;</span></span><br><span class="line">JAVA_OPT=<span class="string">&quot;<span class="variable">$&#123;JAVA_OPT&#125;</span> -XX:MaxDirectMemorySize=256m&quot;</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>可以用命令 JPS 查看启动进程，成功了的话需要启动两个 broker 和一个
server</li>
<li>查看日志</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mac</span></span><br><span class="line"><span class="built_in">tail</span> -200f ~/logs/rocketmqlogs/broker.log</span><br><span class="line"><span class="comment"># Windows</span></span><br><span class="line">C:\Users\asus\logs\rocketmqlogs\broker.log</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://twoandone.github.io/2021/03/23/JVM-GC%E5%8F%82%E6%95%B0-xms-xss-xmn-xss-%E5%8A%A9%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yussss">
      <meta itemprop="description" content="后端废物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Yussss">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/23/JVM-GC%E5%8F%82%E6%95%B0-xms-xss-xmn-xss-%E5%8A%A9%E8%AE%B0/" class="post-title-link" itemprop="url">JVM GC参数(Xmn,Xms,Xmx,Xss)助记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-23 12:18:20" itemprop="dateCreated datePublished" datetime="2021-03-23T12:18:20+08:00">2021-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-03-28 13:52:45" itemprop="dateModified" datetime="2021-03-28T13:52:45+08:00">2021-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="overview">Overview</h2>
<p><strong>太长不看总结:</strong></p>
<table>
<thead>
<tr class="header">
<th>Option</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-</td>
<td>标准VM 选项</td>
</tr>
<tr class="even">
<td>-X</td>
<td>非标准VM选项</td>
</tr>
<tr class="odd">
<td>-Xms</td>
<td>maximum size 设置堆的最大初始初始值</td>
</tr>
<tr class="even">
<td>-Xmn</td>
<td>maximum nursery 设置堆中新生代的最大初始值</td>
</tr>
<tr class="odd">
<td>-Xmx</td>
<td>memory maximum 设置堆的最大值</td>
</tr>
<tr class="even">
<td>-Xss</td>
<td>stack size 设置线程中栈的内容大小</td>
</tr>
</tbody>
</table>
<p>-Xms, -Xms, -Xmn, -Xss</p>
<p>在看技术博客时,看到到这些参数是不是很无语,完全不知道说的是啥,根本无法理解!</p>
<p>但是仔细想想写JDK的那群神仙会像我们这种菜鸟随便命名吗?</p>
<p>所以我放下书本去翻了一下文档</p>
<p>https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</p>
<blockquote>
<p>OptionsThe <code>java</code> command supports a wide range of options
that can be divided into the following categories:</p>
<ul>
<li><a
target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BABDJJFI">Standard
Options</a></li>
<li><a
target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BABHDABI">Non-Standard
Options</a></li>
<li><a
target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BABCBGHF">Advanced
Runtime Options</a></li>
<li><a
target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BABDDFII">Advanced
JIT Compiler Options</a></li>
<li><a
target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BABFJDIC">Advanced
Serviceability Options</a></li>
<li><a
target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html#BABFAFAE">Advanced
Garbage Collection Options</a></li>
</ul>
<p>Standard options are guaranteed to be supported by all
implementations of the Java Virtual Machine (JVM). They are used for
common actions, such as checking the version of the JRE, setting the
class path, enabling verbose output, and so on.</p>
<p>Non-standard options are general purpose options that are specific to
the Java HotSpot Virtual Machine, so they are not guaranteed to be
supported by all JVM implementations, and are subject to change. These
options start with <code>-X</code>.</p>
<p>Advanced options are not recommended for casual use. These are
developer options used for tuning specific areas of the Java HotSpot
Virtual Machine operation that often have specific system requirements
and may require privileged access to system configuration parameters.
They are also not guaranteed to be supported by all JVM implementations,
and are subject to change. Advanced options start with
<code>-XX</code>.</p>
</blockquote>
<p>翻译一下,大概就是java提供了很多命令,有标准的,有非标准的,非标准的就得用<code>-X</code>开头,进阶一点不建议平时使用的用<code>-XX</code>开头</p>
<p>好的,我们已经明白这几个命令的开头是什么意思了</p>
<ul>
<li>- : 标准VM选项，VM规范的选项</li>
<li>-X: 非标准VM选项，不保证所有VM支持</li>
<li>-XX: 高级选项，高级特性，但属于不稳定的选项</li>
</ul>
<h2 id="xmn">-Xmn</h2>
<blockquote>
<p>Sets the initial and maximum size (in bytes) of the heap for the
young generation (nursery).</p>
</blockquote>
<p>为新生代设置在堆上的初始最大值</p>
<blockquote>
<p>Append the letter <code>k</code> or <code>K</code> to indicate
kilobytes, <code>m</code> or <code>M</code> to indicate megabytes,
<code>g</code> or <code>G</code> to indicate gigabytes.</p>
</blockquote>
<p>参数后可以指定单位,比如用k、m、g</p>
<blockquote>
<p>The young generation region of the heap is used for new objects. GC
is performed in this region more often than in other regions. If the
size for the young generation is too small, then a lot of minor garbage
collections will be performed. If the size is too large, then only full
garbage collections will be performed, which can take a long time to
complete.</p>
</blockquote>
<p>堆的新生代区域用于新对象。GC在这个区域执行的频率高于其他区域。如果年轻代size太小，那么将执行大量次要的垃圾收集。如果size太大，则只有完整的垃圾收集才会被执行，这可能需要很长时间才能完成。</p>
<blockquote>
<p>Oracle recommends that you keep the size for the young generation
between a half and a quarter of the overall heap size.</p>
</blockquote>
<p>Oracle建议将新生代的堆的size保持在总体堆size的二分之一到四分之一之间。</p>
<blockquote>
<p>The following examples show how to set the initial and maximum size
of young generation to 256 MB using various units:</p>
<p>-Xmn256m</p>
<p>-Xmn262144k</p>
<p>-Xmn268435456</p>
<p>Instead of the <code>-Xmn</code> option to set both the initial and
maximum size of the heap for the young generation, you can use
<code>-XX:NewSize</code> to set the initial size and
<code>-XX:MaxNewSize</code> to set the maximum size.</p>
</blockquote>
<p>下面是使用不同的单位设置新生代的例子,不翻译了,都能看懂.</p>
<p><strong>总结</strong></p>
<p>-Xmn 指的是,</p>
<ul>
<li><p>-X:非标准VM选项</p></li>
<li><p>m:maximum 最大</p></li>
<li><p>n: nursery :托儿所</p></li>
</ul>
<p>最大的托儿所,就是新生代最大size</p>
<h2 id="xms">-Xms</h2>
<blockquote>
<p>Sets the initial size (in bytes) of the heap. This value must be a
multiple of 1024 and greater than 1 MB. Append the letter <code>k</code>
or <code>K</code> to indicate kilobytes, <code>m</code> or
<code>M</code> to indicate megabytes, <code>g</code> or <code>G</code>
to indicate gigabytes.</p>
</blockquote>
<p>设置堆的初始最大size,这个值必须是1024的倍数,必须大于1MB,可以用k、m、g做参数后面的单位</p>
<blockquote>
<p>The following examples show how to set the size of allocated memory
to 6 MB using various units:</p>
<p><code>-Xms6291456 -Xms6144k -Xms6m</code></p>
</blockquote>
<p>下面是一些例子,用不同单位设置6MB的最大内存</p>
<p><strong>总结</strong></p>
<ul>
<li><p>-X:非标准VM选项</p></li>
<li><p>m:最大 maximum</p></li>
<li><p>s:大小 size</p></li>
</ul>
<p>在堆上初始最大的容量</p>
<h2 id="xmx">-Xmx</h2>
<blockquote>
<p>Specifies the maximum size (in bytes) of the memory allocation pool
in bytes. This value must be a multiple of 1024 and greater than 2 MB.
Append the letter <code>k</code> or <code>K</code> to indicate
kilobytes, <code>m</code> or <code>M</code> to indicate megabytes,
<code>g</code> or <code>G</code> to indicate gigabytes.</p>
</blockquote>
<p>指定堆的最大值,跟-Xms的区别是,ms是初始值,这个是可容纳的最大值</p>
<blockquote>
<p>The default value is chosen at runtime based on system configuration.
For server deployments, <code>-Xms</code> and <code>-Xmx</code> are
often set to the same value. See the section "Ergonomics" in <em>Java SE
HotSpot Virtual Machine Garbage Collection Tuning Guide</em> at
`<code>http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html</code>.</p>
</blockquote>
<p>默认值是基于系统配置在运行时选择的,在服务部署时,-Xms与-Xmx一般被设置为同样的大小</p>
<blockquote>
<p>The following examples show how to set the maximum allowed size of
allocated memory to 80 MB using various units:</p>
</blockquote>
<p>80MB的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xmx83886080</span><br><span class="line">-Xmx81920k</span><br><span class="line">-Xmx80m</span><br></pre></td></tr></table></figure>
<p>The <code>-Xmx</code> option is equivalent to
<code>-XX:MaxHeapSize</code>.</p>
<p><strong>总结</strong></p>
<ul>
<li><p>-X:非标准VM选项</p></li>
<li><p>m:最大 memory</p></li>
<li><p>x:大小 maximum</p></li>
</ul>
<p>最大的容量</p>
<h2 id="xss">-Xss</h2>
<blockquote>
<p>Sets the thread stack size (in bytes). Append the letter
<code>k</code> or <code>K</code> to indicate KB, <code>m</code> or
<code>M</code> to indicate MB, <code>g</code> or <code>G</code> to
indicate GB. The default value depends on virtual memory.</p>
</blockquote>
<p>设置线程栈的大小,可以用不同的单位来设置,默认值取决于虚拟机.</p>
<p>The following examples set the thread stack size to 1024 KB in
different units:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure>
<p>This option is equivalent to <code>-XX:ThreadStackSize</code>.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://twoandone.github.io/2021/03/23/%E7%90%86%E8%A7%A3%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Yus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yussss">
      <meta itemprop="description" content="后端废物">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Yussss">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/23/%E7%90%86%E8%A7%A3%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">理解强引用、软引用、弱引用、虚引用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-23 12:03:09" itemprop="dateCreated datePublished" datetime="2021-03-23T12:03:09+08:00">2021-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-18 01:03:09" itemprop="dateModified" datetime="2022-07-18T01:03:09+08:00">2022-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="强引用">强引用</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reference</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">testReference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        test = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test被回收了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>强引用是最普遍的引用,在代码中随处可见,只要某个对象与强引用关联,这个对象就不会被回收,JVM宁愿抛出OOM也不会回收.</p>
<p>那么什么时候才能被回收呢?</p>
<p>手动把引用指向null,比如上述代码中</p>
<p><code>test = null</code></p>
<h1 id="软引用">软引用</h1>
<figure>
<img
src="https://github.com/TwoAndOne/my-images/raw/master/img/image-20210323132537741.png"
alt="image-20210323132537741" />
<figcaption aria-hidden="true">image-20210323132537741</figcaption>
</figure>
<figure>
<img
src="https://github.com/TwoAndOne/my-images/raw/master/img/image-20210323132606414.png"
alt="image-20210323132606414" />
<figcaption aria-hidden="true">image-20210323132606414</figcaption>
</figure>
<p>软引用需要用SoftReference对象包装一下</p>
<p>它的特点是,当内存不足时,就会触发JVM的GC,如果GC后内存还是不足,就会把软引用包裹的对象回收.也就是说只有当内存不足时,JVM才会回收软引用</p>
<p>解释一下图片的例子:</p>
<p>创建一个软引用对象,里面包裹byte[],byte[]占用10M,设置JVM运行参数,-Xmx,表示堆内存最大容量</p>
<p>这个参数不懂的可以参考笔者另一篇文章</p>
<p>第一次用softReference.get()方法获取该引用的地址</p>
<p>手动打开GC</p>
<p>GC后,测试发现该引用还是存在,这是因为内存还比较充足</p>
<p>接着再创建一个10M的byte[]对象</p>
<p>再次用softReference.get()方法获取软引用的地址,发现已经为null了</p>
<p><strong>软引用的作用</strong></p>
<p>做缓存吧,内存够就正常拿缓存,内存不够就干掉它,不至于马上抛出OOM</p>
<h2 id="弱引用">弱引用</h2>
<figure>
<img
src="https://github.com/TwoAndOne/my-images/raw/master/img/image-20210323133735452.png"
alt="image-20210323133735452" />
<figcaption aria-hidden="true">image-20210323133735452</figcaption>
</figure>
<p>弱引用是用WeakReference来包裹对象</p>
<p>无论有没有内存,gc遇到它就回收</p>
<p><strong>什么时候用呢</strong></p>
<p>ThreadLocal,WeakHashMap</p>
<p>ThreadLocal是一个本地线程副本变量工具类。内部是一个<strong>弱引用</strong>的Map来维护。</p>
<p>WeakHashMap其实和HashMap大多数行为是一样的，只是WeakHashMap不会阻止GC回收key对象（不是value）</p>
<h2 id="虚引用">虚引用</h2>
<figure>
<img
src="https://github.com/TwoAndOne/my-images/raw/master/img/image-20210323134603056.png"
alt="image-20210323134603056" />
<figcaption aria-hidden="true">image-20210323134603056</figcaption>
</figure>
<p>运行完直接返回null,说明根本拿不到虚引用指向的对象</p>
<p>看图中,创建虚引用不仅需要传入被包裹对象,还得传入一个ReferenceQueue ,
当GC准备回收一个对象时,如果发现它还有虚引用,就会在回收之前,把这个虚引用加入到与之关联的ReferenceQueue中.</p>
<p>平时没用到虚引用,所以我也不是很懂,待续.......</p>
<p>NIO中好像使用了虚引用管理堆外内存.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2017 – 
  <span itemprop="copyrightYear">2023</span>
<!--  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
-->
 by 
  <span class="author" itemprop="copyrightHolder">Yus</span>
</div>

<!-- -->

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
